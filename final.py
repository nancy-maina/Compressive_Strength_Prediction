# -*- coding: utf-8 -*-
"""final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C-GvO1qBgG8x0lYxOLfoEN-PIzxTOsww
"""

# Import necessary libraries
import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

from google.colab import drive
drive.mount('/content/drive')

path = "/content/drive/MyDrive/Compressive Strength.csv"

data = pd.read_csv("/content/drive/MyDrive/Compressive Strength.csv")

data.head()

# Split data into features and target
X = data.iloc[:, :-1]
y = data.iloc[:, -1]

# Standardize features
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Split data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)

# Build the model
model = Sequential()
model.add(Dense(8,activation='relu'))

for i in range(0, 44):
  # All layers utilize rectified linear units (relu)
  model.add(Dense(8,activation='relu'))

# Output
model.add(Dense(1))

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=200, 
          batch_size= 128,
           validation_data=(X_test,y_test.values),
          verbose=0)

# Evaluate the model on the test set
mse = model.evaluate(X_test, y_test)

# Predict the compressive strength of concrete using the trained model
predictions = model.predict(X_test)

print("Mean Squared Error:", mse)

predictions = model.predict(X_train)
y_pred = model.predict(X_test)
score = model.evaluate(X_test, y_test, verbose=0)
print("Test loss: {:.2f}".format(score))

# Model Evaluation
from sklearn.metrics import mean_squared_error, mean_absolute_error, explained_variance_score
from sklearn.linear_model import LinearRegression


# Model Evaluation Metrics
MAE = mean_absolute_error(y_test,y_pred)
RMSE = np.sqrt(mean_squared_error(y_test,y_pred))                 
EVS = explained_variance_score(y_test,y_pred)

print('EVALUATION METRICS')
print('-----------------------------')
print(f"Mean Absolute Error (MAE):\t\t{MAE}\nRoot Mean Squared Error (RMSE):\t\t{RMSE}\nExplained Variance Score:\t\t{EVS}")

from sklearn.preprocessing import MinMaxScaler, normalize

min_max_scaler = MinMaxScaler()
values = np.array ([5, 10, 0, 0.5, 0, 10, 10, 28])
# values = np.array([0, 0, 0, 0, 0, 0, 0, 0])
values = normalize([values])

prediction = model.predict(values)
print(prediction)

# Save the weights of the trained model
model.save_weights('my_model_weights.h5')

